// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.12.4
// source: protos/semantics.proto

/* eslint-disable */
import Long from 'long';
import _m0 from 'protobufjs/minimal';

export const protobufPackage = 'querent.semantics';

export enum Model {
	BERT = 0,
	GeoBert = 1,
	PubMedBert = 2,
	UNRECOGNIZED = -1
}

export function modelFromJSON(object: any): Model {
	switch (object) {
		case 0:
		case 'BERT':
			return Model.BERT;
		case 1:
		case 'GeoBert':
			return Model.GeoBert;
		case 2:
		case 'PubMedBert':
			return Model.PubMedBert;
		case -1:
		case 'UNRECOGNIZED':
		default:
			return Model.UNRECOGNIZED;
	}
}

export function modelToJSON(object: Model): string {
	switch (object) {
		case Model.BERT:
			return 'BERT';
		case Model.GeoBert:
			return 'GeoBert';
		case Model.PubMedBert:
			return 'PubMedBert';
		case Model.UNRECOGNIZED:
		default:
			return 'UNRECOGNIZED';
	}
}

export interface PipelineRequestInfoList {
	requests: PipelineRequestInfo[];
}

export interface PipelineRequestInfo {
	pipelineId: string;
	request: SemanticPipelineRequest | undefined;
}

export interface EmptyObserve {}

export interface EmptyList {}

export interface EmptyGetPipelinesMetadata {}

export interface StopPipelineRequest {
	pipelineId: string;
}

export interface DescribePipelineRequest {
	pipelineId: string;
}

export interface RestartPipelineRequest {
	pipelineId: string;
}

export interface CollectorConfigResponse {
	id: string;
}

export interface DeleteCollectorRequest {
	id: string[];
}

export interface DeleteCollectorResponse {
	id: string[];
}

export interface ListCollectorRequest {}

export interface ListCollectorConfig {
	config: CollectorConfig[];
}

export interface SemanticPipelineRequest {
	collectors: string[];
	fixedEntities?: FixedEntities | undefined;
	sampleEntities?: SampleEntities | undefined;
	model?: Model | undefined;
	attentionThreshold?: number | undefined;
}

export interface FixedEntities {
	entities: string[];
}

export interface SampleEntities {
	entities: string[];
}

export interface SemanticPipelineResponse {
	pipelineId: string;
}

export interface SemanticServiceCounters {
	numRunningPipelines: number;
	numSuccessfulPipelines: number;
	numFailedPipelines: number;
}

export interface IngestedTokens {
	file: string;
	data: string[];
	isTokenStream: boolean;
	docSource: string;
	sourceId: string;
}

export interface SendIngestedTokens {
	pipelineId: string;
	tokens: IngestedTokens[];
}

export interface IndexingStatistics {
	totalDocs: number;
	totalEvents: number;
	totalEventsProcessed: number;
	totalEventsReceived: number;
	totalEventsSent: number;
	totalBatches: number;
	totalSentences: number;
	totalSubjects: number;
	totalPredicates: number;
	totalObjects: number;
	totalGraphEvents: number;
	totalVectorEvents: number;
	totalDataProcessedSize: number;
}

export interface PipelineMetadata {
	pipelineId: string;
}

export interface PipelinesMetadata {
	pipelines: PipelineMetadata[];
}

export interface BooleanResponse {
	response: boolean;
}

/**
 * CollectorConfig is a message to hold configuration for a collector.
 * Defines a collector with a specific configuration.
 */
export interface CollectorConfig {
	name: string;
	azure?: AzureCollectorConfig | undefined;
	gcs?: GCSCollectorConfig | undefined;
	s3?: S3CollectorConfig | undefined;
	jira?: JiraCollectorConfig | undefined;
	drive?: GoogleDriveCollectorConfig | undefined;
	email?: EmailCollectorConfig | undefined;
	dropbox?: DropBoxCollectorConfig | undefined;
	github?: GithubCollectorConfig | undefined;
	slack?: SlackCollectorConfig | undefined;
	news?: NewsCollectorConfig | undefined;
	files?: FileCollectorConfig | undefined;
	onedrive?: OneDriveConfig | undefined;
}

/** FileCollectorConfig is a message to hold configuration for a file collector. */
export interface FileCollectorConfig {
	rootPath: string;
	/** Id for the collector */
	id: string;
}

/** AzureCollectorConfig is a message to hold configuration for an Azure collector. */
export interface AzureCollectorConfig {
	/** Connection string of the Azure collector. */
	connectionString: string;
	/** Container of the Azure collector. */
	container: string;
	/** Credentials of the Azure collector. */
	credentials: string;
	/** Prefix of the Azure collector. */
	prefix: string;
	/** Chunk size of the Azure collector. */
	chunkSize: number;
	/** Id for the collector */
	id: string;
}

/** GCSCollectorConfig is a message to hold configuration for a GCS collector. */
export interface GCSCollectorConfig {
	/** Bucket of the GCS collector. */
	bucket: string;
	/** Credentials of the GCS collector. */
	credentials: string;
	/** Id for the collector */
	id: string;
}

/** S3CollectorConfig is a message to hold configuration for an S3 collector. */
export interface S3CollectorConfig {
	/** Access key of the S3 collector. */
	accessKey: string;
	/** Secret key of the S3 collector. */
	secretKey: string;
	/** Region of the S3 collector. */
	region: string;
	/** Bucket of the S3 collector. */
	bucket: string;
	/** Id for the collector */
	id: string;
}

/** JiraCollectorConfig is a message to hold configuration for a Jira collector. */
export interface JiraCollectorConfig {
	/** Server of the Jira collector. */
	jiraServer: string;
	/** Username of the Jira collector. */
	jiraUsername: string;
	/** Password of the Jira collector. */
	jiraPassword: string;
	/** API token of the Jira collector. */
	jiraApiToken: string;
	/** Certificate file of the Jira collector. */
	jiraCertfile: string;
	/** Key file of the Jira collector. */
	jiraKeyfile: string;
	/** Verify of the Jira collector. */
	jiraVerify: boolean;
	/** Project of the Jira collector. */
	jiraProject: string;
	/** Query of the Jira collector. */
	jiraQuery: string;
	/** Start at of the Jira collector. */
	jiraStartAt: number;
	/** Max results of the Jira collector. */
	jiraMaxResults: number;
	/** Id for the collector */
	id: string;
}

/** GoogleDriveCollectorConfig is a message to hold configuration for a Google Drive collector. */
export interface GoogleDriveCollectorConfig {
	/** Client ID of the Google Drive collector. */
	driveClientId: string;
	/** Client secret of the Google Drive collector. */
	driveClientSecret: string;
	/** Refresh token of the Google Drive collector. */
	driveRefreshToken: string;
	/** Folder to crawl of the Google Drive collector. */
	folderToCrawl: string;
	/** Id for the collector */
	id: string;
}

/** EmailCollectorConfig is a message to hold configuration for an Email collector. */
export interface EmailCollectorConfig {
	/** Server of the Email collector. */
	imapServer: string;
	/** Port of the Email collector. */
	imapPort: number;
	/** Username of the Email collector. */
	imapUsername: string;
	/** Password of the Email collector. */
	imapPassword: string;
	/** Folder of the Email collector. */
	imapFolder: string;
	/** Id for the collector */
	id: string;
}

/** DropBoxCollectorConfig is a message to hold configuration for a DropBox collector. */
export interface DropBoxCollectorConfig {
	/** App key of the DropBox collector. */
	dropboxAppKey: string;
	/** App secret of the DropBox collector. */
	dropboxAppSecret: string;
	/** Refresh token of the DropBox collector. */
	dropboxRefreshToken: string;
	/** Folder path of the DropBox collector. */
	folderPath: string;
	/** Id for the collector */
	id: string;
}

/** GithubCollectorConfig is a message to hold configuration for a Github collector. */
export interface GithubCollectorConfig {
	/** Username of the Github collector. */
	githubUsername: string;
	/** Access token of the Github collector. */
	githubAccessToken: string;
	/** Repository of the Github collector. */
	repository: string;
	/** Id for the collector */
	id: string;
}

/** SlackCollectorConfig is a message to hold configuration for a Slack collector. */
export interface SlackCollectorConfig {
	/** Access token of the Slack collector. */
	accessToken: string;
	/** Channel name of the Slack collector. */
	channelName: string;
	/** Cursor of the Slack collector. */
	cursor: string;
	/** Include all metadata of the Slack collector. */
	includeAllMetadata: boolean;
	/** Includive of the Slack collector. */
	includive: boolean;
	/** Limit of the Slack collector. */
	limit: number;
	/** Id for the collector */
	id: string;
}

/** NewsCollectorConfig is a message to hold configuration for a News collector. */
export interface NewsCollectorConfig {
	/** API key of the News collector. */
	apiKey: string;
	/** Query of the News collector. */
	query: string;
	/** From date of the News collector. */
	fromDate: string;
	/** To date of the News collector. */
	toDate: string;
	/** Language of the News collector. */
	language: string;
	/** Domains of the News collector. */
	domains: string;
	/** Exclude domains of the News collector. */
	excludeDomains: string;
	/** Sources of the News collector. */
	sources: string;
	/** Id for the collector */
	id: string;
}

export interface OneDriveConfig {
	/** Client ID of the app */
	clientId: string;
	/** Client secret of the app */
	clientSecret: string;
	/** Redirect URI */
	redirectUri: string;
	/** Refresh token of the app */
	refreshToken: string;
	/** / Folder path of the app */
	folderPath: string;
	/** / Id for the collector */
	id: string;
}

function createBasePipelineRequestInfoList(): PipelineRequestInfoList {
	return { requests: [] };
}

export const PipelineRequestInfoList = {
	encode(message: PipelineRequestInfoList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.requests) {
			PipelineRequestInfo.encode(v!, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): PipelineRequestInfoList {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePipelineRequestInfoList();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.requests.push(PipelineRequestInfo.decode(reader, reader.uint32()));
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PipelineRequestInfoList {
		return {
			requests: globalThis.Array.isArray(object?.requests)
				? object.requests.map((e: any) => PipelineRequestInfo.fromJSON(e))
				: []
		};
	},

	toJSON(message: PipelineRequestInfoList): unknown {
		const obj: any = {};
		if (message.requests?.length) {
			obj.requests = message.requests.map((e) => PipelineRequestInfo.toJSON(e));
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PipelineRequestInfoList>, I>>(
		base?: I
	): PipelineRequestInfoList {
		return PipelineRequestInfoList.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PipelineRequestInfoList>, I>>(
		object: I
	): PipelineRequestInfoList {
		const message = createBasePipelineRequestInfoList();
		message.requests = object.requests?.map((e) => PipelineRequestInfo.fromPartial(e)) || [];
		return message;
	}
};

function createBasePipelineRequestInfo(): PipelineRequestInfo {
	return { pipelineId: '', request: undefined };
}

export const PipelineRequestInfo = {
	encode(message: PipelineRequestInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		if (message.request !== undefined) {
			SemanticPipelineRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): PipelineRequestInfo {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePipelineRequestInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.request = SemanticPipelineRequest.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PipelineRequestInfo {
		return {
			pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '',
			request: isSet(object.request) ? SemanticPipelineRequest.fromJSON(object.request) : undefined
		};
	},

	toJSON(message: PipelineRequestInfo): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		if (message.request !== undefined) {
			obj.request = SemanticPipelineRequest.toJSON(message.request);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PipelineRequestInfo>, I>>(base?: I): PipelineRequestInfo {
		return PipelineRequestInfo.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PipelineRequestInfo>, I>>(
		object: I
	): PipelineRequestInfo {
		const message = createBasePipelineRequestInfo();
		message.pipelineId = object.pipelineId ?? '';
		message.request =
			object.request !== undefined && object.request !== null
				? SemanticPipelineRequest.fromPartial(object.request)
				: undefined;
		return message;
	}
};

function createBaseEmptyObserve(): EmptyObserve {
	return {};
}

export const EmptyObserve = {
	encode(_: EmptyObserve, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): EmptyObserve {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseEmptyObserve();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): EmptyObserve {
		return {};
	},

	toJSON(_: EmptyObserve): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<EmptyObserve>, I>>(base?: I): EmptyObserve {
		return EmptyObserve.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<EmptyObserve>, I>>(_: I): EmptyObserve {
		const message = createBaseEmptyObserve();
		return message;
	}
};

function createBaseEmptyList(): EmptyList {
	return {};
}

export const EmptyList = {
	encode(_: EmptyList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): EmptyList {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseEmptyList();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): EmptyList {
		return {};
	},

	toJSON(_: EmptyList): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<EmptyList>, I>>(base?: I): EmptyList {
		return EmptyList.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<EmptyList>, I>>(_: I): EmptyList {
		const message = createBaseEmptyList();
		return message;
	}
};

function createBaseEmptyGetPipelinesMetadata(): EmptyGetPipelinesMetadata {
	return {};
}

export const EmptyGetPipelinesMetadata = {
	encode(_: EmptyGetPipelinesMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): EmptyGetPipelinesMetadata {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseEmptyGetPipelinesMetadata();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): EmptyGetPipelinesMetadata {
		return {};
	},

	toJSON(_: EmptyGetPipelinesMetadata): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<EmptyGetPipelinesMetadata>, I>>(
		base?: I
	): EmptyGetPipelinesMetadata {
		return EmptyGetPipelinesMetadata.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<EmptyGetPipelinesMetadata>, I>>(
		_: I
	): EmptyGetPipelinesMetadata {
		const message = createBaseEmptyGetPipelinesMetadata();
		return message;
	}
};

function createBaseStopPipelineRequest(): StopPipelineRequest {
	return { pipelineId: '' };
}

export const StopPipelineRequest = {
	encode(message: StopPipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): StopPipelineRequest {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseStopPipelineRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): StopPipelineRequest {
		return { pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '' };
	},

	toJSON(message: StopPipelineRequest): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<StopPipelineRequest>, I>>(base?: I): StopPipelineRequest {
		return StopPipelineRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<StopPipelineRequest>, I>>(
		object: I
	): StopPipelineRequest {
		const message = createBaseStopPipelineRequest();
		message.pipelineId = object.pipelineId ?? '';
		return message;
	}
};

function createBaseDescribePipelineRequest(): DescribePipelineRequest {
	return { pipelineId: '' };
}

export const DescribePipelineRequest = {
	encode(message: DescribePipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): DescribePipelineRequest {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDescribePipelineRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DescribePipelineRequest {
		return { pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '' };
	},

	toJSON(message: DescribePipelineRequest): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DescribePipelineRequest>, I>>(
		base?: I
	): DescribePipelineRequest {
		return DescribePipelineRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DescribePipelineRequest>, I>>(
		object: I
	): DescribePipelineRequest {
		const message = createBaseDescribePipelineRequest();
		message.pipelineId = object.pipelineId ?? '';
		return message;
	}
};

function createBaseRestartPipelineRequest(): RestartPipelineRequest {
	return { pipelineId: '' };
}

export const RestartPipelineRequest = {
	encode(message: RestartPipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): RestartPipelineRequest {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRestartPipelineRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RestartPipelineRequest {
		return { pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '' };
	},

	toJSON(message: RestartPipelineRequest): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<RestartPipelineRequest>, I>>(
		base?: I
	): RestartPipelineRequest {
		return RestartPipelineRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<RestartPipelineRequest>, I>>(
		object: I
	): RestartPipelineRequest {
		const message = createBaseRestartPipelineRequest();
		message.pipelineId = object.pipelineId ?? '';
		return message;
	}
};

function createBaseCollectorConfigResponse(): CollectorConfigResponse {
	return { id: '' };
}

export const CollectorConfigResponse = {
	encode(message: CollectorConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.id !== '') {
			writer.uint32(10).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): CollectorConfigResponse {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCollectorConfigResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CollectorConfigResponse {
		return { id: isSet(object.id) ? globalThis.String(object.id) : '' };
	},

	toJSON(message: CollectorConfigResponse): unknown {
		const obj: any = {};
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CollectorConfigResponse>, I>>(
		base?: I
	): CollectorConfigResponse {
		return CollectorConfigResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CollectorConfigResponse>, I>>(
		object: I
	): CollectorConfigResponse {
		const message = createBaseCollectorConfigResponse();
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseDeleteCollectorRequest(): DeleteCollectorRequest {
	return { id: [] };
}

export const DeleteCollectorRequest = {
	encode(message: DeleteCollectorRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.id) {
			writer.uint32(10).string(v!);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCollectorRequest {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDeleteCollectorRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.id.push(reader.string());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DeleteCollectorRequest {
		return {
			id: globalThis.Array.isArray(object?.id)
				? object.id.map((e: any) => globalThis.String(e))
				: []
		};
	},

	toJSON(message: DeleteCollectorRequest): unknown {
		const obj: any = {};
		if (message.id?.length) {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DeleteCollectorRequest>, I>>(
		base?: I
	): DeleteCollectorRequest {
		return DeleteCollectorRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DeleteCollectorRequest>, I>>(
		object: I
	): DeleteCollectorRequest {
		const message = createBaseDeleteCollectorRequest();
		message.id = object.id?.map((e) => e) || [];
		return message;
	}
};

function createBaseDeleteCollectorResponse(): DeleteCollectorResponse {
	return { id: [] };
}

export const DeleteCollectorResponse = {
	encode(message: DeleteCollectorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.id) {
			writer.uint32(10).string(v!);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCollectorResponse {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDeleteCollectorResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.id.push(reader.string());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DeleteCollectorResponse {
		return {
			id: globalThis.Array.isArray(object?.id)
				? object.id.map((e: any) => globalThis.String(e))
				: []
		};
	},

	toJSON(message: DeleteCollectorResponse): unknown {
		const obj: any = {};
		if (message.id?.length) {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DeleteCollectorResponse>, I>>(
		base?: I
	): DeleteCollectorResponse {
		return DeleteCollectorResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DeleteCollectorResponse>, I>>(
		object: I
	): DeleteCollectorResponse {
		const message = createBaseDeleteCollectorResponse();
		message.id = object.id?.map((e) => e) || [];
		return message;
	}
};

function createBaseListCollectorRequest(): ListCollectorRequest {
	return {};
}

export const ListCollectorRequest = {
	encode(_: ListCollectorRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): ListCollectorRequest {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseListCollectorRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): ListCollectorRequest {
		return {};
	},

	toJSON(_: ListCollectorRequest): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<ListCollectorRequest>, I>>(base?: I): ListCollectorRequest {
		return ListCollectorRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<ListCollectorRequest>, I>>(_: I): ListCollectorRequest {
		const message = createBaseListCollectorRequest();
		return message;
	}
};

function createBaseListCollectorConfig(): ListCollectorConfig {
	return { config: [] };
}

export const ListCollectorConfig = {
	encode(message: ListCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.config) {
			CollectorConfig.encode(v!, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): ListCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseListCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.config.push(CollectorConfig.decode(reader, reader.uint32()));
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ListCollectorConfig {
		return {
			config: globalThis.Array.isArray(object?.config)
				? object.config.map((e: any) => CollectorConfig.fromJSON(e))
				: []
		};
	},

	toJSON(message: ListCollectorConfig): unknown {
		const obj: any = {};
		if (message.config?.length) {
			obj.config = message.config.map((e) => CollectorConfig.toJSON(e));
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<ListCollectorConfig>, I>>(base?: I): ListCollectorConfig {
		return ListCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<ListCollectorConfig>, I>>(
		object: I
	): ListCollectorConfig {
		const message = createBaseListCollectorConfig();
		message.config = object.config?.map((e) => CollectorConfig.fromPartial(e)) || [];
		return message;
	}
};

function createBaseSemanticPipelineRequest(): SemanticPipelineRequest {
	return {
		collectors: [],
		fixedEntities: undefined,
		sampleEntities: undefined,
		model: undefined,
		attentionThreshold: undefined
	};
}

export const SemanticPipelineRequest = {
	encode(message: SemanticPipelineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.collectors) {
			writer.uint32(10).string(v!);
		}
		if (message.fixedEntities !== undefined) {
			FixedEntities.encode(message.fixedEntities, writer.uint32(18).fork()).ldelim();
		}
		if (message.sampleEntities !== undefined) {
			SampleEntities.encode(message.sampleEntities, writer.uint32(26).fork()).ldelim();
		}
		if (message.model !== undefined) {
			writer.uint32(32).int32(message.model);
		}
		if (message.attentionThreshold !== undefined) {
			writer.uint32(45).float(message.attentionThreshold);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): SemanticPipelineRequest {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSemanticPipelineRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.collectors.push(reader.string());
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.fixedEntities = FixedEntities.decode(reader, reader.uint32());
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.sampleEntities = SampleEntities.decode(reader, reader.uint32());
					continue;
				case 4:
					if (tag !== 32) {
						break;
					}

					message.model = reader.int32() as any;
					continue;
				case 5:
					if (tag !== 45) {
						break;
					}

					message.attentionThreshold = reader.float();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SemanticPipelineRequest {
		return {
			collectors: globalThis.Array.isArray(object?.collectors)
				? object.collectors.map((e: any) => globalThis.String(e))
				: [],
			fixedEntities: isSet(object.fixedEntities)
				? FixedEntities.fromJSON(object.fixedEntities)
				: undefined,
			sampleEntities: isSet(object.sampleEntities)
				? SampleEntities.fromJSON(object.sampleEntities)
				: undefined,
			model: isSet(object.model) ? modelFromJSON(object.model) : undefined,
			attentionThreshold: isSet(object.attentionThreshold)
				? globalThis.Number(object.attentionThreshold)
				: undefined
		};
	},

	toJSON(message: SemanticPipelineRequest): unknown {
		const obj: any = {};
		if (message.collectors?.length) {
			obj.collectors = message.collectors;
		}
		if (message.fixedEntities !== undefined) {
			obj.fixedEntities = FixedEntities.toJSON(message.fixedEntities);
		}
		if (message.sampleEntities !== undefined) {
			obj.sampleEntities = SampleEntities.toJSON(message.sampleEntities);
		}
		if (message.model !== undefined) {
			obj.model = modelToJSON(message.model);
		}
		if (message.attentionThreshold !== undefined) {
			obj.attentionThreshold = message.attentionThreshold;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SemanticPipelineRequest>, I>>(
		base?: I
	): SemanticPipelineRequest {
		return SemanticPipelineRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SemanticPipelineRequest>, I>>(
		object: I
	): SemanticPipelineRequest {
		const message = createBaseSemanticPipelineRequest();
		message.collectors = object.collectors?.map((e) => e) || [];
		message.fixedEntities =
			object.fixedEntities !== undefined && object.fixedEntities !== null
				? FixedEntities.fromPartial(object.fixedEntities)
				: undefined;
		message.sampleEntities =
			object.sampleEntities !== undefined && object.sampleEntities !== null
				? SampleEntities.fromPartial(object.sampleEntities)
				: undefined;
		message.model = object.model ?? undefined;
		message.attentionThreshold = object.attentionThreshold ?? undefined;
		return message;
	}
};

function createBaseFixedEntities(): FixedEntities {
	return { entities: [] };
}

export const FixedEntities = {
	encode(message: FixedEntities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.entities) {
			writer.uint32(10).string(v!);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): FixedEntities {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFixedEntities();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.entities.push(reader.string());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): FixedEntities {
		return {
			entities: globalThis.Array.isArray(object?.entities)
				? object.entities.map((e: any) => globalThis.String(e))
				: []
		};
	},

	toJSON(message: FixedEntities): unknown {
		const obj: any = {};
		if (message.entities?.length) {
			obj.entities = message.entities;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<FixedEntities>, I>>(base?: I): FixedEntities {
		return FixedEntities.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<FixedEntities>, I>>(object: I): FixedEntities {
		const message = createBaseFixedEntities();
		message.entities = object.entities?.map((e) => e) || [];
		return message;
	}
};

function createBaseSampleEntities(): SampleEntities {
	return { entities: [] };
}

export const SampleEntities = {
	encode(message: SampleEntities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.entities) {
			writer.uint32(10).string(v!);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): SampleEntities {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSampleEntities();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.entities.push(reader.string());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SampleEntities {
		return {
			entities: globalThis.Array.isArray(object?.entities)
				? object.entities.map((e: any) => globalThis.String(e))
				: []
		};
	},

	toJSON(message: SampleEntities): unknown {
		const obj: any = {};
		if (message.entities?.length) {
			obj.entities = message.entities;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SampleEntities>, I>>(base?: I): SampleEntities {
		return SampleEntities.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SampleEntities>, I>>(object: I): SampleEntities {
		const message = createBaseSampleEntities();
		message.entities = object.entities?.map((e) => e) || [];
		return message;
	}
};

function createBaseSemanticPipelineResponse(): SemanticPipelineResponse {
	return { pipelineId: '' };
}

export const SemanticPipelineResponse = {
	encode(message: SemanticPipelineResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): SemanticPipelineResponse {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSemanticPipelineResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SemanticPipelineResponse {
		return { pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '' };
	},

	toJSON(message: SemanticPipelineResponse): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SemanticPipelineResponse>, I>>(
		base?: I
	): SemanticPipelineResponse {
		return SemanticPipelineResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SemanticPipelineResponse>, I>>(
		object: I
	): SemanticPipelineResponse {
		const message = createBaseSemanticPipelineResponse();
		message.pipelineId = object.pipelineId ?? '';
		return message;
	}
};

function createBaseSemanticServiceCounters(): SemanticServiceCounters {
	return { numRunningPipelines: 0, numSuccessfulPipelines: 0, numFailedPipelines: 0 };
}

export const SemanticServiceCounters = {
	encode(message: SemanticServiceCounters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.numRunningPipelines !== 0) {
			writer.uint32(8).int32(message.numRunningPipelines);
		}
		if (message.numSuccessfulPipelines !== 0) {
			writer.uint32(16).int32(message.numSuccessfulPipelines);
		}
		if (message.numFailedPipelines !== 0) {
			writer.uint32(24).int32(message.numFailedPipelines);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): SemanticServiceCounters {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSemanticServiceCounters();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 8) {
						break;
					}

					message.numRunningPipelines = reader.int32();
					continue;
				case 2:
					if (tag !== 16) {
						break;
					}

					message.numSuccessfulPipelines = reader.int32();
					continue;
				case 3:
					if (tag !== 24) {
						break;
					}

					message.numFailedPipelines = reader.int32();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SemanticServiceCounters {
		return {
			numRunningPipelines: isSet(object.numRunningPipelines)
				? globalThis.Number(object.numRunningPipelines)
				: 0,
			numSuccessfulPipelines: isSet(object.numSuccessfulPipelines)
				? globalThis.Number(object.numSuccessfulPipelines)
				: 0,
			numFailedPipelines: isSet(object.numFailedPipelines)
				? globalThis.Number(object.numFailedPipelines)
				: 0
		};
	},

	toJSON(message: SemanticServiceCounters): unknown {
		const obj: any = {};
		if (message.numRunningPipelines !== 0) {
			obj.numRunningPipelines = Math.round(message.numRunningPipelines);
		}
		if (message.numSuccessfulPipelines !== 0) {
			obj.numSuccessfulPipelines = Math.round(message.numSuccessfulPipelines);
		}
		if (message.numFailedPipelines !== 0) {
			obj.numFailedPipelines = Math.round(message.numFailedPipelines);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SemanticServiceCounters>, I>>(
		base?: I
	): SemanticServiceCounters {
		return SemanticServiceCounters.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SemanticServiceCounters>, I>>(
		object: I
	): SemanticServiceCounters {
		const message = createBaseSemanticServiceCounters();
		message.numRunningPipelines = object.numRunningPipelines ?? 0;
		message.numSuccessfulPipelines = object.numSuccessfulPipelines ?? 0;
		message.numFailedPipelines = object.numFailedPipelines ?? 0;
		return message;
	}
};

function createBaseIngestedTokens(): IngestedTokens {
	return { file: '', data: [], isTokenStream: false, docSource: '', sourceId: '' };
}

export const IngestedTokens = {
	encode(message: IngestedTokens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.file !== '') {
			writer.uint32(10).string(message.file);
		}
		for (const v of message.data) {
			writer.uint32(18).string(v!);
		}
		if (message.isTokenStream !== false) {
			writer.uint32(24).bool(message.isTokenStream);
		}
		if (message.docSource !== '') {
			writer.uint32(34).string(message.docSource);
		}
		if (message.sourceId !== '') {
			writer.uint32(42).string(message.sourceId);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): IngestedTokens {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseIngestedTokens();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.file = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.data.push(reader.string());
					continue;
				case 3:
					if (tag !== 24) {
						break;
					}

					message.isTokenStream = reader.bool();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.docSource = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.sourceId = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): IngestedTokens {
		return {
			file: isSet(object.file) ? globalThis.String(object.file) : '',
			data: globalThis.Array.isArray(object?.data)
				? object.data.map((e: any) => globalThis.String(e))
				: [],
			isTokenStream: isSet(object.isTokenStream) ? globalThis.Boolean(object.isTokenStream) : false,
			docSource: isSet(object.docSource) ? globalThis.String(object.docSource) : '',
			sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : ''
		};
	},

	toJSON(message: IngestedTokens): unknown {
		const obj: any = {};
		if (message.file !== '') {
			obj.file = message.file;
		}
		if (message.data?.length) {
			obj.data = message.data;
		}
		if (message.isTokenStream !== false) {
			obj.isTokenStream = message.isTokenStream;
		}
		if (message.docSource !== '') {
			obj.docSource = message.docSource;
		}
		if (message.sourceId !== '') {
			obj.sourceId = message.sourceId;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<IngestedTokens>, I>>(base?: I): IngestedTokens {
		return IngestedTokens.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<IngestedTokens>, I>>(object: I): IngestedTokens {
		const message = createBaseIngestedTokens();
		message.file = object.file ?? '';
		message.data = object.data?.map((e) => e) || [];
		message.isTokenStream = object.isTokenStream ?? false;
		message.docSource = object.docSource ?? '';
		message.sourceId = object.sourceId ?? '';
		return message;
	}
};

function createBaseSendIngestedTokens(): SendIngestedTokens {
	return { pipelineId: '', tokens: [] };
}

export const SendIngestedTokens = {
	encode(message: SendIngestedTokens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		for (const v of message.tokens) {
			IngestedTokens.encode(v!, writer.uint32(18).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): SendIngestedTokens {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSendIngestedTokens();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.tokens.push(IngestedTokens.decode(reader, reader.uint32()));
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SendIngestedTokens {
		return {
			pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '',
			tokens: globalThis.Array.isArray(object?.tokens)
				? object.tokens.map((e: any) => IngestedTokens.fromJSON(e))
				: []
		};
	},

	toJSON(message: SendIngestedTokens): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		if (message.tokens?.length) {
			obj.tokens = message.tokens.map((e) => IngestedTokens.toJSON(e));
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SendIngestedTokens>, I>>(base?: I): SendIngestedTokens {
		return SendIngestedTokens.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SendIngestedTokens>, I>>(object: I): SendIngestedTokens {
		const message = createBaseSendIngestedTokens();
		message.pipelineId = object.pipelineId ?? '';
		message.tokens = object.tokens?.map((e) => IngestedTokens.fromPartial(e)) || [];
		return message;
	}
};

function createBaseIndexingStatistics(): IndexingStatistics {
	return {
		totalDocs: 0,
		totalEvents: 0,
		totalEventsProcessed: 0,
		totalEventsReceived: 0,
		totalEventsSent: 0,
		totalBatches: 0,
		totalSentences: 0,
		totalSubjects: 0,
		totalPredicates: 0,
		totalObjects: 0,
		totalGraphEvents: 0,
		totalVectorEvents: 0,
		totalDataProcessedSize: 0
	};
}

export const IndexingStatistics = {
	encode(message: IndexingStatistics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.totalDocs !== 0) {
			writer.uint32(8).uint64(message.totalDocs);
		}
		if (message.totalEvents !== 0) {
			writer.uint32(16).uint64(message.totalEvents);
		}
		if (message.totalEventsProcessed !== 0) {
			writer.uint32(24).uint64(message.totalEventsProcessed);
		}
		if (message.totalEventsReceived !== 0) {
			writer.uint32(32).uint64(message.totalEventsReceived);
		}
		if (message.totalEventsSent !== 0) {
			writer.uint32(40).uint64(message.totalEventsSent);
		}
		if (message.totalBatches !== 0) {
			writer.uint32(48).uint64(message.totalBatches);
		}
		if (message.totalSentences !== 0) {
			writer.uint32(56).uint64(message.totalSentences);
		}
		if (message.totalSubjects !== 0) {
			writer.uint32(64).uint64(message.totalSubjects);
		}
		if (message.totalPredicates !== 0) {
			writer.uint32(72).uint64(message.totalPredicates);
		}
		if (message.totalObjects !== 0) {
			writer.uint32(80).uint64(message.totalObjects);
		}
		if (message.totalGraphEvents !== 0) {
			writer.uint32(88).uint64(message.totalGraphEvents);
		}
		if (message.totalVectorEvents !== 0) {
			writer.uint32(96).uint64(message.totalVectorEvents);
		}
		if (message.totalDataProcessedSize !== 0) {
			writer.uint32(104).uint64(message.totalDataProcessedSize);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): IndexingStatistics {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseIndexingStatistics();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 8) {
						break;
					}

					message.totalDocs = longToNumber(reader.uint64() as Long);
					continue;
				case 2:
					if (tag !== 16) {
						break;
					}

					message.totalEvents = longToNumber(reader.uint64() as Long);
					continue;
				case 3:
					if (tag !== 24) {
						break;
					}

					message.totalEventsProcessed = longToNumber(reader.uint64() as Long);
					continue;
				case 4:
					if (tag !== 32) {
						break;
					}

					message.totalEventsReceived = longToNumber(reader.uint64() as Long);
					continue;
				case 5:
					if (tag !== 40) {
						break;
					}

					message.totalEventsSent = longToNumber(reader.uint64() as Long);
					continue;
				case 6:
					if (tag !== 48) {
						break;
					}

					message.totalBatches = longToNumber(reader.uint64() as Long);
					continue;
				case 7:
					if (tag !== 56) {
						break;
					}

					message.totalSentences = longToNumber(reader.uint64() as Long);
					continue;
				case 8:
					if (tag !== 64) {
						break;
					}

					message.totalSubjects = longToNumber(reader.uint64() as Long);
					continue;
				case 9:
					if (tag !== 72) {
						break;
					}

					message.totalPredicates = longToNumber(reader.uint64() as Long);
					continue;
				case 10:
					if (tag !== 80) {
						break;
					}

					message.totalObjects = longToNumber(reader.uint64() as Long);
					continue;
				case 11:
					if (tag !== 88) {
						break;
					}

					message.totalGraphEvents = longToNumber(reader.uint64() as Long);
					continue;
				case 12:
					if (tag !== 96) {
						break;
					}

					message.totalVectorEvents = longToNumber(reader.uint64() as Long);
					continue;
				case 13:
					if (tag !== 104) {
						break;
					}

					message.totalDataProcessedSize = longToNumber(reader.uint64() as Long);
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): IndexingStatistics {
		return {
			totalDocs: isSet(object.totalDocs) ? globalThis.Number(object.totalDocs) : 0,
			totalEvents: isSet(object.totalEvents) ? globalThis.Number(object.totalEvents) : 0,
			totalEventsProcessed: isSet(object.totalEventsProcessed)
				? globalThis.Number(object.totalEventsProcessed)
				: 0,
			totalEventsReceived: isSet(object.totalEventsReceived)
				? globalThis.Number(object.totalEventsReceived)
				: 0,
			totalEventsSent: isSet(object.totalEventsSent)
				? globalThis.Number(object.totalEventsSent)
				: 0,
			totalBatches: isSet(object.totalBatches) ? globalThis.Number(object.totalBatches) : 0,
			totalSentences: isSet(object.totalSentences) ? globalThis.Number(object.totalSentences) : 0,
			totalSubjects: isSet(object.totalSubjects) ? globalThis.Number(object.totalSubjects) : 0,
			totalPredicates: isSet(object.totalPredicates)
				? globalThis.Number(object.totalPredicates)
				: 0,
			totalObjects: isSet(object.totalObjects) ? globalThis.Number(object.totalObjects) : 0,
			totalGraphEvents: isSet(object.totalGraphEvents)
				? globalThis.Number(object.totalGraphEvents)
				: 0,
			totalVectorEvents: isSet(object.totalVectorEvents)
				? globalThis.Number(object.totalVectorEvents)
				: 0,
			totalDataProcessedSize: isSet(object.totalDataProcessedSize)
				? globalThis.Number(object.totalDataProcessedSize)
				: 0
		};
	},

	toJSON(message: IndexingStatistics): unknown {
		const obj: any = {};
		if (message.totalDocs !== 0) {
			obj.totalDocs = Math.round(message.totalDocs);
		}
		if (message.totalEvents !== 0) {
			obj.totalEvents = Math.round(message.totalEvents);
		}
		if (message.totalEventsProcessed !== 0) {
			obj.totalEventsProcessed = Math.round(message.totalEventsProcessed);
		}
		if (message.totalEventsReceived !== 0) {
			obj.totalEventsReceived = Math.round(message.totalEventsReceived);
		}
		if (message.totalEventsSent !== 0) {
			obj.totalEventsSent = Math.round(message.totalEventsSent);
		}
		if (message.totalBatches !== 0) {
			obj.totalBatches = Math.round(message.totalBatches);
		}
		if (message.totalSentences !== 0) {
			obj.totalSentences = Math.round(message.totalSentences);
		}
		if (message.totalSubjects !== 0) {
			obj.totalSubjects = Math.round(message.totalSubjects);
		}
		if (message.totalPredicates !== 0) {
			obj.totalPredicates = Math.round(message.totalPredicates);
		}
		if (message.totalObjects !== 0) {
			obj.totalObjects = Math.round(message.totalObjects);
		}
		if (message.totalGraphEvents !== 0) {
			obj.totalGraphEvents = Math.round(message.totalGraphEvents);
		}
		if (message.totalVectorEvents !== 0) {
			obj.totalVectorEvents = Math.round(message.totalVectorEvents);
		}
		if (message.totalDataProcessedSize !== 0) {
			obj.totalDataProcessedSize = Math.round(message.totalDataProcessedSize);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<IndexingStatistics>, I>>(base?: I): IndexingStatistics {
		return IndexingStatistics.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<IndexingStatistics>, I>>(object: I): IndexingStatistics {
		const message = createBaseIndexingStatistics();
		message.totalDocs = object.totalDocs ?? 0;
		message.totalEvents = object.totalEvents ?? 0;
		message.totalEventsProcessed = object.totalEventsProcessed ?? 0;
		message.totalEventsReceived = object.totalEventsReceived ?? 0;
		message.totalEventsSent = object.totalEventsSent ?? 0;
		message.totalBatches = object.totalBatches ?? 0;
		message.totalSentences = object.totalSentences ?? 0;
		message.totalSubjects = object.totalSubjects ?? 0;
		message.totalPredicates = object.totalPredicates ?? 0;
		message.totalObjects = object.totalObjects ?? 0;
		message.totalGraphEvents = object.totalGraphEvents ?? 0;
		message.totalVectorEvents = object.totalVectorEvents ?? 0;
		message.totalDataProcessedSize = object.totalDataProcessedSize ?? 0;
		return message;
	}
};

function createBasePipelineMetadata(): PipelineMetadata {
	return { pipelineId: '' };
}

export const PipelineMetadata = {
	encode(message: PipelineMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.pipelineId !== '') {
			writer.uint32(10).string(message.pipelineId);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): PipelineMetadata {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePipelineMetadata();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelineId = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PipelineMetadata {
		return { pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : '' };
	},

	toJSON(message: PipelineMetadata): unknown {
		const obj: any = {};
		if (message.pipelineId !== '') {
			obj.pipelineId = message.pipelineId;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PipelineMetadata>, I>>(base?: I): PipelineMetadata {
		return PipelineMetadata.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PipelineMetadata>, I>>(object: I): PipelineMetadata {
		const message = createBasePipelineMetadata();
		message.pipelineId = object.pipelineId ?? '';
		return message;
	}
};

function createBasePipelinesMetadata(): PipelinesMetadata {
	return { pipelines: [] };
}

export const PipelinesMetadata = {
	encode(message: PipelinesMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		for (const v of message.pipelines) {
			PipelineMetadata.encode(v!, writer.uint32(10).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): PipelinesMetadata {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePipelinesMetadata();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pipelines.push(PipelineMetadata.decode(reader, reader.uint32()));
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PipelinesMetadata {
		return {
			pipelines: globalThis.Array.isArray(object?.pipelines)
				? object.pipelines.map((e: any) => PipelineMetadata.fromJSON(e))
				: []
		};
	},

	toJSON(message: PipelinesMetadata): unknown {
		const obj: any = {};
		if (message.pipelines?.length) {
			obj.pipelines = message.pipelines.map((e) => PipelineMetadata.toJSON(e));
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PipelinesMetadata>, I>>(base?: I): PipelinesMetadata {
		return PipelinesMetadata.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PipelinesMetadata>, I>>(object: I): PipelinesMetadata {
		const message = createBasePipelinesMetadata();
		message.pipelines = object.pipelines?.map((e) => PipelineMetadata.fromPartial(e)) || [];
		return message;
	}
};

function createBaseBooleanResponse(): BooleanResponse {
	return { response: false };
}

export const BooleanResponse = {
	encode(message: BooleanResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.response !== false) {
			writer.uint32(8).bool(message.response);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): BooleanResponse {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBooleanResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 8) {
						break;
					}

					message.response = reader.bool();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): BooleanResponse {
		return { response: isSet(object.response) ? globalThis.Boolean(object.response) : false };
	},

	toJSON(message: BooleanResponse): unknown {
		const obj: any = {};
		if (message.response !== false) {
			obj.response = message.response;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<BooleanResponse>, I>>(base?: I): BooleanResponse {
		return BooleanResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<BooleanResponse>, I>>(object: I): BooleanResponse {
		const message = createBaseBooleanResponse();
		message.response = object.response ?? false;
		return message;
	}
};

function createBaseCollectorConfig(): CollectorConfig {
	return {
		name: '',
		azure: undefined,
		gcs: undefined,
		s3: undefined,
		jira: undefined,
		drive: undefined,
		email: undefined,
		dropbox: undefined,
		github: undefined,
		slack: undefined,
		news: undefined,
		files: undefined,
		onedrive: undefined
	};
}

export const CollectorConfig = {
	encode(message: CollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.name !== '') {
			writer.uint32(10).string(message.name);
		}
		if (message.azure !== undefined) {
			AzureCollectorConfig.encode(message.azure, writer.uint32(18).fork()).ldelim();
		}
		if (message.gcs !== undefined) {
			GCSCollectorConfig.encode(message.gcs, writer.uint32(26).fork()).ldelim();
		}
		if (message.s3 !== undefined) {
			S3CollectorConfig.encode(message.s3, writer.uint32(34).fork()).ldelim();
		}
		if (message.jira !== undefined) {
			JiraCollectorConfig.encode(message.jira, writer.uint32(42).fork()).ldelim();
		}
		if (message.drive !== undefined) {
			GoogleDriveCollectorConfig.encode(message.drive, writer.uint32(50).fork()).ldelim();
		}
		if (message.email !== undefined) {
			EmailCollectorConfig.encode(message.email, writer.uint32(58).fork()).ldelim();
		}
		if (message.dropbox !== undefined) {
			DropBoxCollectorConfig.encode(message.dropbox, writer.uint32(66).fork()).ldelim();
		}
		if (message.github !== undefined) {
			GithubCollectorConfig.encode(message.github, writer.uint32(74).fork()).ldelim();
		}
		if (message.slack !== undefined) {
			SlackCollectorConfig.encode(message.slack, writer.uint32(82).fork()).ldelim();
		}
		if (message.news !== undefined) {
			NewsCollectorConfig.encode(message.news, writer.uint32(90).fork()).ldelim();
		}
		if (message.files !== undefined) {
			FileCollectorConfig.encode(message.files, writer.uint32(98).fork()).ldelim();
		}
		if (message.onedrive !== undefined) {
			OneDriveConfig.encode(message.onedrive, writer.uint32(106).fork()).ldelim();
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): CollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.name = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.azure = AzureCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.gcs = GCSCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.s3 = S3CollectorConfig.decode(reader, reader.uint32());
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.jira = JiraCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.drive = GoogleDriveCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 7:
					if (tag !== 58) {
						break;
					}

					message.email = EmailCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 8:
					if (tag !== 66) {
						break;
					}

					message.dropbox = DropBoxCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 9:
					if (tag !== 74) {
						break;
					}

					message.github = GithubCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 10:
					if (tag !== 82) {
						break;
					}

					message.slack = SlackCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 11:
					if (tag !== 90) {
						break;
					}

					message.news = NewsCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 12:
					if (tag !== 98) {
						break;
					}

					message.files = FileCollectorConfig.decode(reader, reader.uint32());
					continue;
				case 13:
					if (tag !== 106) {
						break;
					}

					message.onedrive = OneDriveConfig.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CollectorConfig {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : '',
			azure: isSet(object.azure) ? AzureCollectorConfig.fromJSON(object.azure) : undefined,
			gcs: isSet(object.gcs) ? GCSCollectorConfig.fromJSON(object.gcs) : undefined,
			s3: isSet(object.s3) ? S3CollectorConfig.fromJSON(object.s3) : undefined,
			jira: isSet(object.jira) ? JiraCollectorConfig.fromJSON(object.jira) : undefined,
			drive: isSet(object.drive) ? GoogleDriveCollectorConfig.fromJSON(object.drive) : undefined,
			email: isSet(object.email) ? EmailCollectorConfig.fromJSON(object.email) : undefined,
			dropbox: isSet(object.dropbox) ? DropBoxCollectorConfig.fromJSON(object.dropbox) : undefined,
			github: isSet(object.github) ? GithubCollectorConfig.fromJSON(object.github) : undefined,
			slack: isSet(object.slack) ? SlackCollectorConfig.fromJSON(object.slack) : undefined,
			news: isSet(object.news) ? NewsCollectorConfig.fromJSON(object.news) : undefined,
			files: isSet(object.files) ? FileCollectorConfig.fromJSON(object.files) : undefined,
			onedrive: isSet(object.onedrive) ? OneDriveConfig.fromJSON(object.onedrive) : undefined
		};
	},

	toJSON(message: CollectorConfig): unknown {
		const obj: any = {};
		if (message.name !== '') {
			obj.name = message.name;
		}
		if (message.azure !== undefined) {
			obj.azure = AzureCollectorConfig.toJSON(message.azure);
		}
		if (message.gcs !== undefined) {
			obj.gcs = GCSCollectorConfig.toJSON(message.gcs);
		}
		if (message.s3 !== undefined) {
			obj.s3 = S3CollectorConfig.toJSON(message.s3);
		}
		if (message.jira !== undefined) {
			obj.jira = JiraCollectorConfig.toJSON(message.jira);
		}
		if (message.drive !== undefined) {
			obj.drive = GoogleDriveCollectorConfig.toJSON(message.drive);
		}
		if (message.email !== undefined) {
			obj.email = EmailCollectorConfig.toJSON(message.email);
		}
		if (message.dropbox !== undefined) {
			obj.dropbox = DropBoxCollectorConfig.toJSON(message.dropbox);
		}
		if (message.github !== undefined) {
			obj.github = GithubCollectorConfig.toJSON(message.github);
		}
		if (message.slack !== undefined) {
			obj.slack = SlackCollectorConfig.toJSON(message.slack);
		}
		if (message.news !== undefined) {
			obj.news = NewsCollectorConfig.toJSON(message.news);
		}
		if (message.files !== undefined) {
			obj.files = FileCollectorConfig.toJSON(message.files);
		}
		if (message.onedrive !== undefined) {
			obj.onedrive = OneDriveConfig.toJSON(message.onedrive);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CollectorConfig>, I>>(base?: I): CollectorConfig {
		return CollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CollectorConfig>, I>>(object: I): CollectorConfig {
		const message = createBaseCollectorConfig();
		message.name = object.name ?? '';
		message.azure =
			object.azure !== undefined && object.azure !== null
				? AzureCollectorConfig.fromPartial(object.azure)
				: undefined;
		message.gcs =
			object.gcs !== undefined && object.gcs !== null
				? GCSCollectorConfig.fromPartial(object.gcs)
				: undefined;
		message.s3 =
			object.s3 !== undefined && object.s3 !== null
				? S3CollectorConfig.fromPartial(object.s3)
				: undefined;
		message.jira =
			object.jira !== undefined && object.jira !== null
				? JiraCollectorConfig.fromPartial(object.jira)
				: undefined;
		message.drive =
			object.drive !== undefined && object.drive !== null
				? GoogleDriveCollectorConfig.fromPartial(object.drive)
				: undefined;
		message.email =
			object.email !== undefined && object.email !== null
				? EmailCollectorConfig.fromPartial(object.email)
				: undefined;
		message.dropbox =
			object.dropbox !== undefined && object.dropbox !== null
				? DropBoxCollectorConfig.fromPartial(object.dropbox)
				: undefined;
		message.github =
			object.github !== undefined && object.github !== null
				? GithubCollectorConfig.fromPartial(object.github)
				: undefined;
		message.slack =
			object.slack !== undefined && object.slack !== null
				? SlackCollectorConfig.fromPartial(object.slack)
				: undefined;
		message.news =
			object.news !== undefined && object.news !== null
				? NewsCollectorConfig.fromPartial(object.news)
				: undefined;
		message.files =
			object.files !== undefined && object.files !== null
				? FileCollectorConfig.fromPartial(object.files)
				: undefined;
		message.onedrive =
			object.onedrive !== undefined && object.onedrive !== null
				? OneDriveConfig.fromPartial(object.onedrive)
				: undefined;
		return message;
	}
};

function createBaseFileCollectorConfig(): FileCollectorConfig {
	return { rootPath: '', id: '' };
}

export const FileCollectorConfig = {
	encode(message: FileCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.rootPath !== '') {
			writer.uint32(10).string(message.rootPath);
		}
		if (message.id !== '') {
			writer.uint32(18).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): FileCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFileCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.rootPath = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): FileCollectorConfig {
		return {
			rootPath: isSet(object.rootPath) ? globalThis.String(object.rootPath) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: FileCollectorConfig): unknown {
		const obj: any = {};
		if (message.rootPath !== '') {
			obj.rootPath = message.rootPath;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<FileCollectorConfig>, I>>(base?: I): FileCollectorConfig {
		return FileCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<FileCollectorConfig>, I>>(
		object: I
	): FileCollectorConfig {
		const message = createBaseFileCollectorConfig();
		message.rootPath = object.rootPath ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseAzureCollectorConfig(): AzureCollectorConfig {
	return { connectionString: '', container: '', credentials: '', prefix: '', chunkSize: 0, id: '' };
}

export const AzureCollectorConfig = {
	encode(message: AzureCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.connectionString !== '') {
			writer.uint32(18).string(message.connectionString);
		}
		if (message.container !== '') {
			writer.uint32(26).string(message.container);
		}
		if (message.credentials !== '') {
			writer.uint32(34).string(message.credentials);
		}
		if (message.prefix !== '') {
			writer.uint32(42).string(message.prefix);
		}
		if (message.chunkSize !== 0) {
			writer.uint32(48).int64(message.chunkSize);
		}
		if (message.id !== '') {
			writer.uint32(58).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): AzureCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseAzureCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2:
					if (tag !== 18) {
						break;
					}

					message.connectionString = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.container = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.credentials = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.prefix = reader.string();
					continue;
				case 6:
					if (tag !== 48) {
						break;
					}

					message.chunkSize = longToNumber(reader.int64() as Long);
					continue;
				case 7:
					if (tag !== 58) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): AzureCollectorConfig {
		return {
			connectionString: isSet(object.connectionString)
				? globalThis.String(object.connectionString)
				: '',
			container: isSet(object.container) ? globalThis.String(object.container) : '',
			credentials: isSet(object.credentials) ? globalThis.String(object.credentials) : '',
			prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : '',
			chunkSize: isSet(object.chunkSize) ? globalThis.Number(object.chunkSize) : 0,
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: AzureCollectorConfig): unknown {
		const obj: any = {};
		if (message.connectionString !== '') {
			obj.connectionString = message.connectionString;
		}
		if (message.container !== '') {
			obj.container = message.container;
		}
		if (message.credentials !== '') {
			obj.credentials = message.credentials;
		}
		if (message.prefix !== '') {
			obj.prefix = message.prefix;
		}
		if (message.chunkSize !== 0) {
			obj.chunkSize = Math.round(message.chunkSize);
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<AzureCollectorConfig>, I>>(base?: I): AzureCollectorConfig {
		return AzureCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<AzureCollectorConfig>, I>>(
		object: I
	): AzureCollectorConfig {
		const message = createBaseAzureCollectorConfig();
		message.connectionString = object.connectionString ?? '';
		message.container = object.container ?? '';
		message.credentials = object.credentials ?? '';
		message.prefix = object.prefix ?? '';
		message.chunkSize = object.chunkSize ?? 0;
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseGCSCollectorConfig(): GCSCollectorConfig {
	return { bucket: '', credentials: '', id: '' };
}

export const GCSCollectorConfig = {
	encode(message: GCSCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.bucket !== '') {
			writer.uint32(10).string(message.bucket);
		}
		if (message.credentials !== '') {
			writer.uint32(18).string(message.credentials);
		}
		if (message.id !== '') {
			writer.uint32(26).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): GCSCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGCSCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.bucket = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.credentials = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GCSCollectorConfig {
		return {
			bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : '',
			credentials: isSet(object.credentials) ? globalThis.String(object.credentials) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: GCSCollectorConfig): unknown {
		const obj: any = {};
		if (message.bucket !== '') {
			obj.bucket = message.bucket;
		}
		if (message.credentials !== '') {
			obj.credentials = message.credentials;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GCSCollectorConfig>, I>>(base?: I): GCSCollectorConfig {
		return GCSCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GCSCollectorConfig>, I>>(object: I): GCSCollectorConfig {
		const message = createBaseGCSCollectorConfig();
		message.bucket = object.bucket ?? '';
		message.credentials = object.credentials ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseS3CollectorConfig(): S3CollectorConfig {
	return { accessKey: '', secretKey: '', region: '', bucket: '', id: '' };
}

export const S3CollectorConfig = {
	encode(message: S3CollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.accessKey !== '') {
			writer.uint32(10).string(message.accessKey);
		}
		if (message.secretKey !== '') {
			writer.uint32(18).string(message.secretKey);
		}
		if (message.region !== '') {
			writer.uint32(26).string(message.region);
		}
		if (message.bucket !== '') {
			writer.uint32(34).string(message.bucket);
		}
		if (message.id !== '') {
			writer.uint32(42).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): S3CollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseS3CollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.accessKey = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.secretKey = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.region = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.bucket = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): S3CollectorConfig {
		return {
			accessKey: isSet(object.accessKey) ? globalThis.String(object.accessKey) : '',
			secretKey: isSet(object.secretKey) ? globalThis.String(object.secretKey) : '',
			region: isSet(object.region) ? globalThis.String(object.region) : '',
			bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: S3CollectorConfig): unknown {
		const obj: any = {};
		if (message.accessKey !== '') {
			obj.accessKey = message.accessKey;
		}
		if (message.secretKey !== '') {
			obj.secretKey = message.secretKey;
		}
		if (message.region !== '') {
			obj.region = message.region;
		}
		if (message.bucket !== '') {
			obj.bucket = message.bucket;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<S3CollectorConfig>, I>>(base?: I): S3CollectorConfig {
		return S3CollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<S3CollectorConfig>, I>>(object: I): S3CollectorConfig {
		const message = createBaseS3CollectorConfig();
		message.accessKey = object.accessKey ?? '';
		message.secretKey = object.secretKey ?? '';
		message.region = object.region ?? '';
		message.bucket = object.bucket ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseJiraCollectorConfig(): JiraCollectorConfig {
	return {
		jiraServer: '',
		jiraUsername: '',
		jiraPassword: '',
		jiraApiToken: '',
		jiraCertfile: '',
		jiraKeyfile: '',
		jiraVerify: false,
		jiraProject: '',
		jiraQuery: '',
		jiraStartAt: 0,
		jiraMaxResults: 0,
		id: ''
	};
}

export const JiraCollectorConfig = {
	encode(message: JiraCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.jiraServer !== '') {
			writer.uint32(10).string(message.jiraServer);
		}
		if (message.jiraUsername !== '') {
			writer.uint32(18).string(message.jiraUsername);
		}
		if (message.jiraPassword !== '') {
			writer.uint32(26).string(message.jiraPassword);
		}
		if (message.jiraApiToken !== '') {
			writer.uint32(34).string(message.jiraApiToken);
		}
		if (message.jiraCertfile !== '') {
			writer.uint32(42).string(message.jiraCertfile);
		}
		if (message.jiraKeyfile !== '') {
			writer.uint32(50).string(message.jiraKeyfile);
		}
		if (message.jiraVerify !== false) {
			writer.uint32(56).bool(message.jiraVerify);
		}
		if (message.jiraProject !== '') {
			writer.uint32(66).string(message.jiraProject);
		}
		if (message.jiraQuery !== '') {
			writer.uint32(74).string(message.jiraQuery);
		}
		if (message.jiraStartAt !== 0) {
			writer.uint32(80).int32(message.jiraStartAt);
		}
		if (message.jiraMaxResults !== 0) {
			writer.uint32(88).int32(message.jiraMaxResults);
		}
		if (message.id !== '') {
			writer.uint32(98).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): JiraCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseJiraCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.jiraServer = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.jiraUsername = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.jiraPassword = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.jiraApiToken = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.jiraCertfile = reader.string();
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.jiraKeyfile = reader.string();
					continue;
				case 7:
					if (tag !== 56) {
						break;
					}

					message.jiraVerify = reader.bool();
					continue;
				case 8:
					if (tag !== 66) {
						break;
					}

					message.jiraProject = reader.string();
					continue;
				case 9:
					if (tag !== 74) {
						break;
					}

					message.jiraQuery = reader.string();
					continue;
				case 10:
					if (tag !== 80) {
						break;
					}

					message.jiraStartAt = reader.int32();
					continue;
				case 11:
					if (tag !== 88) {
						break;
					}

					message.jiraMaxResults = reader.int32();
					continue;
				case 12:
					if (tag !== 98) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): JiraCollectorConfig {
		return {
			jiraServer: isSet(object.jiraServer) ? globalThis.String(object.jiraServer) : '',
			jiraUsername: isSet(object.jiraUsername) ? globalThis.String(object.jiraUsername) : '',
			jiraPassword: isSet(object.jiraPassword) ? globalThis.String(object.jiraPassword) : '',
			jiraApiToken: isSet(object.jiraApiToken) ? globalThis.String(object.jiraApiToken) : '',
			jiraCertfile: isSet(object.jiraCertfile) ? globalThis.String(object.jiraCertfile) : '',
			jiraKeyfile: isSet(object.jiraKeyfile) ? globalThis.String(object.jiraKeyfile) : '',
			jiraVerify: isSet(object.jiraVerify) ? globalThis.Boolean(object.jiraVerify) : false,
			jiraProject: isSet(object.jiraProject) ? globalThis.String(object.jiraProject) : '',
			jiraQuery: isSet(object.jiraQuery) ? globalThis.String(object.jiraQuery) : '',
			jiraStartAt: isSet(object.jiraStartAt) ? globalThis.Number(object.jiraStartAt) : 0,
			jiraMaxResults: isSet(object.jiraMaxResults) ? globalThis.Number(object.jiraMaxResults) : 0,
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: JiraCollectorConfig): unknown {
		const obj: any = {};
		if (message.jiraServer !== '') {
			obj.jiraServer = message.jiraServer;
		}
		if (message.jiraUsername !== '') {
			obj.jiraUsername = message.jiraUsername;
		}
		if (message.jiraPassword !== '') {
			obj.jiraPassword = message.jiraPassword;
		}
		if (message.jiraApiToken !== '') {
			obj.jiraApiToken = message.jiraApiToken;
		}
		if (message.jiraCertfile !== '') {
			obj.jiraCertfile = message.jiraCertfile;
		}
		if (message.jiraKeyfile !== '') {
			obj.jiraKeyfile = message.jiraKeyfile;
		}
		if (message.jiraVerify !== false) {
			obj.jiraVerify = message.jiraVerify;
		}
		if (message.jiraProject !== '') {
			obj.jiraProject = message.jiraProject;
		}
		if (message.jiraQuery !== '') {
			obj.jiraQuery = message.jiraQuery;
		}
		if (message.jiraStartAt !== 0) {
			obj.jiraStartAt = Math.round(message.jiraStartAt);
		}
		if (message.jiraMaxResults !== 0) {
			obj.jiraMaxResults = Math.round(message.jiraMaxResults);
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<JiraCollectorConfig>, I>>(base?: I): JiraCollectorConfig {
		return JiraCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<JiraCollectorConfig>, I>>(
		object: I
	): JiraCollectorConfig {
		const message = createBaseJiraCollectorConfig();
		message.jiraServer = object.jiraServer ?? '';
		message.jiraUsername = object.jiraUsername ?? '';
		message.jiraPassword = object.jiraPassword ?? '';
		message.jiraApiToken = object.jiraApiToken ?? '';
		message.jiraCertfile = object.jiraCertfile ?? '';
		message.jiraKeyfile = object.jiraKeyfile ?? '';
		message.jiraVerify = object.jiraVerify ?? false;
		message.jiraProject = object.jiraProject ?? '';
		message.jiraQuery = object.jiraQuery ?? '';
		message.jiraStartAt = object.jiraStartAt ?? 0;
		message.jiraMaxResults = object.jiraMaxResults ?? 0;
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseGoogleDriveCollectorConfig(): GoogleDriveCollectorConfig {
	return {
		driveClientId: '',
		driveClientSecret: '',
		driveRefreshToken: '',
		folderToCrawl: '',
		id: ''
	};
}

export const GoogleDriveCollectorConfig = {
	encode(
		message: GoogleDriveCollectorConfig,
		writer: _m0.Writer = _m0.Writer.create()
	): _m0.Writer {
		if (message.driveClientId !== '') {
			writer.uint32(10).string(message.driveClientId);
		}
		if (message.driveClientSecret !== '') {
			writer.uint32(18).string(message.driveClientSecret);
		}
		if (message.driveRefreshToken !== '') {
			writer.uint32(26).string(message.driveRefreshToken);
		}
		if (message.folderToCrawl !== '') {
			writer.uint32(34).string(message.folderToCrawl);
		}
		if (message.id !== '') {
			writer.uint32(42).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): GoogleDriveCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGoogleDriveCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.driveClientId = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.driveClientSecret = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.driveRefreshToken = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.folderToCrawl = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GoogleDriveCollectorConfig {
		return {
			driveClientId: isSet(object.driveClientId) ? globalThis.String(object.driveClientId) : '',
			driveClientSecret: isSet(object.driveClientSecret)
				? globalThis.String(object.driveClientSecret)
				: '',
			driveRefreshToken: isSet(object.driveRefreshToken)
				? globalThis.String(object.driveRefreshToken)
				: '',
			folderToCrawl: isSet(object.folderToCrawl) ? globalThis.String(object.folderToCrawl) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: GoogleDriveCollectorConfig): unknown {
		const obj: any = {};
		if (message.driveClientId !== '') {
			obj.driveClientId = message.driveClientId;
		}
		if (message.driveClientSecret !== '') {
			obj.driveClientSecret = message.driveClientSecret;
		}
		if (message.driveRefreshToken !== '') {
			obj.driveRefreshToken = message.driveRefreshToken;
		}
		if (message.folderToCrawl !== '') {
			obj.folderToCrawl = message.folderToCrawl;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GoogleDriveCollectorConfig>, I>>(
		base?: I
	): GoogleDriveCollectorConfig {
		return GoogleDriveCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GoogleDriveCollectorConfig>, I>>(
		object: I
	): GoogleDriveCollectorConfig {
		const message = createBaseGoogleDriveCollectorConfig();
		message.driveClientId = object.driveClientId ?? '';
		message.driveClientSecret = object.driveClientSecret ?? '';
		message.driveRefreshToken = object.driveRefreshToken ?? '';
		message.folderToCrawl = object.folderToCrawl ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseEmailCollectorConfig(): EmailCollectorConfig {
	return {
		imapServer: '',
		imapPort: 0,
		imapUsername: '',
		imapPassword: '',
		imapFolder: '',
		id: ''
	};
}

export const EmailCollectorConfig = {
	encode(message: EmailCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.imapServer !== '') {
			writer.uint32(10).string(message.imapServer);
		}
		if (message.imapPort !== 0) {
			writer.uint32(16).int32(message.imapPort);
		}
		if (message.imapUsername !== '') {
			writer.uint32(26).string(message.imapUsername);
		}
		if (message.imapPassword !== '') {
			writer.uint32(34).string(message.imapPassword);
		}
		if (message.imapFolder !== '') {
			writer.uint32(42).string(message.imapFolder);
		}
		if (message.id !== '') {
			writer.uint32(50).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): EmailCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseEmailCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.imapServer = reader.string();
					continue;
				case 2:
					if (tag !== 16) {
						break;
					}

					message.imapPort = reader.int32();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.imapUsername = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.imapPassword = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.imapFolder = reader.string();
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): EmailCollectorConfig {
		return {
			imapServer: isSet(object.imapServer) ? globalThis.String(object.imapServer) : '',
			imapPort: isSet(object.imapPort) ? globalThis.Number(object.imapPort) : 0,
			imapUsername: isSet(object.imapUsername) ? globalThis.String(object.imapUsername) : '',
			imapPassword: isSet(object.imapPassword) ? globalThis.String(object.imapPassword) : '',
			imapFolder: isSet(object.imapFolder) ? globalThis.String(object.imapFolder) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: EmailCollectorConfig): unknown {
		const obj: any = {};
		if (message.imapServer !== '') {
			obj.imapServer = message.imapServer;
		}
		if (message.imapPort !== 0) {
			obj.imapPort = Math.round(message.imapPort);
		}
		if (message.imapUsername !== '') {
			obj.imapUsername = message.imapUsername;
		}
		if (message.imapPassword !== '') {
			obj.imapPassword = message.imapPassword;
		}
		if (message.imapFolder !== '') {
			obj.imapFolder = message.imapFolder;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<EmailCollectorConfig>, I>>(base?: I): EmailCollectorConfig {
		return EmailCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<EmailCollectorConfig>, I>>(
		object: I
	): EmailCollectorConfig {
		const message = createBaseEmailCollectorConfig();
		message.imapServer = object.imapServer ?? '';
		message.imapPort = object.imapPort ?? 0;
		message.imapUsername = object.imapUsername ?? '';
		message.imapPassword = object.imapPassword ?? '';
		message.imapFolder = object.imapFolder ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseDropBoxCollectorConfig(): DropBoxCollectorConfig {
	return {
		dropboxAppKey: '',
		dropboxAppSecret: '',
		dropboxRefreshToken: '',
		folderPath: '',
		id: ''
	};
}

export const DropBoxCollectorConfig = {
	encode(message: DropBoxCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.dropboxAppKey !== '') {
			writer.uint32(10).string(message.dropboxAppKey);
		}
		if (message.dropboxAppSecret !== '') {
			writer.uint32(18).string(message.dropboxAppSecret);
		}
		if (message.dropboxRefreshToken !== '') {
			writer.uint32(26).string(message.dropboxRefreshToken);
		}
		if (message.folderPath !== '') {
			writer.uint32(34).string(message.folderPath);
		}
		if (message.id !== '') {
			writer.uint32(42).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): DropBoxCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDropBoxCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.dropboxAppKey = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.dropboxAppSecret = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.dropboxRefreshToken = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.folderPath = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DropBoxCollectorConfig {
		return {
			dropboxAppKey: isSet(object.dropboxAppKey) ? globalThis.String(object.dropboxAppKey) : '',
			dropboxAppSecret: isSet(object.dropboxAppSecret)
				? globalThis.String(object.dropboxAppSecret)
				: '',
			dropboxRefreshToken: isSet(object.dropboxRefreshToken)
				? globalThis.String(object.dropboxRefreshToken)
				: '',
			folderPath: isSet(object.folderPath) ? globalThis.String(object.folderPath) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: DropBoxCollectorConfig): unknown {
		const obj: any = {};
		if (message.dropboxAppKey !== '') {
			obj.dropboxAppKey = message.dropboxAppKey;
		}
		if (message.dropboxAppSecret !== '') {
			obj.dropboxAppSecret = message.dropboxAppSecret;
		}
		if (message.dropboxRefreshToken !== '') {
			obj.dropboxRefreshToken = message.dropboxRefreshToken;
		}
		if (message.folderPath !== '') {
			obj.folderPath = message.folderPath;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DropBoxCollectorConfig>, I>>(
		base?: I
	): DropBoxCollectorConfig {
		return DropBoxCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DropBoxCollectorConfig>, I>>(
		object: I
	): DropBoxCollectorConfig {
		const message = createBaseDropBoxCollectorConfig();
		message.dropboxAppKey = object.dropboxAppKey ?? '';
		message.dropboxAppSecret = object.dropboxAppSecret ?? '';
		message.dropboxRefreshToken = object.dropboxRefreshToken ?? '';
		message.folderPath = object.folderPath ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseGithubCollectorConfig(): GithubCollectorConfig {
	return { githubUsername: '', githubAccessToken: '', repository: '', id: '' };
}

export const GithubCollectorConfig = {
	encode(message: GithubCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.githubUsername !== '') {
			writer.uint32(10).string(message.githubUsername);
		}
		if (message.githubAccessToken !== '') {
			writer.uint32(18).string(message.githubAccessToken);
		}
		if (message.repository !== '') {
			writer.uint32(26).string(message.repository);
		}
		if (message.id !== '') {
			writer.uint32(34).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): GithubCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGithubCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.githubUsername = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.githubAccessToken = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.repository = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GithubCollectorConfig {
		return {
			githubUsername: isSet(object.githubUsername) ? globalThis.String(object.githubUsername) : '',
			githubAccessToken: isSet(object.githubAccessToken)
				? globalThis.String(object.githubAccessToken)
				: '',
			repository: isSet(object.repository) ? globalThis.String(object.repository) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: GithubCollectorConfig): unknown {
		const obj: any = {};
		if (message.githubUsername !== '') {
			obj.githubUsername = message.githubUsername;
		}
		if (message.githubAccessToken !== '') {
			obj.githubAccessToken = message.githubAccessToken;
		}
		if (message.repository !== '') {
			obj.repository = message.repository;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GithubCollectorConfig>, I>>(base?: I): GithubCollectorConfig {
		return GithubCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GithubCollectorConfig>, I>>(
		object: I
	): GithubCollectorConfig {
		const message = createBaseGithubCollectorConfig();
		message.githubUsername = object.githubUsername ?? '';
		message.githubAccessToken = object.githubAccessToken ?? '';
		message.repository = object.repository ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseSlackCollectorConfig(): SlackCollectorConfig {
	return {
		accessToken: '',
		channelName: '',
		cursor: '',
		includeAllMetadata: false,
		includive: false,
		limit: 0,
		id: ''
	};
}

export const SlackCollectorConfig = {
	encode(message: SlackCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.accessToken !== '') {
			writer.uint32(10).string(message.accessToken);
		}
		if (message.channelName !== '') {
			writer.uint32(18).string(message.channelName);
		}
		if (message.cursor !== '') {
			writer.uint32(26).string(message.cursor);
		}
		if (message.includeAllMetadata !== false) {
			writer.uint32(32).bool(message.includeAllMetadata);
		}
		if (message.includive !== false) {
			writer.uint32(40).bool(message.includive);
		}
		if (message.limit !== 0) {
			writer.uint32(48).int64(message.limit);
		}
		if (message.id !== '') {
			writer.uint32(58).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): SlackCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSlackCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.accessToken = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.channelName = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.cursor = reader.string();
					continue;
				case 4:
					if (tag !== 32) {
						break;
					}

					message.includeAllMetadata = reader.bool();
					continue;
				case 5:
					if (tag !== 40) {
						break;
					}

					message.includive = reader.bool();
					continue;
				case 6:
					if (tag !== 48) {
						break;
					}

					message.limit = longToNumber(reader.int64() as Long);
					continue;
				case 7:
					if (tag !== 58) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SlackCollectorConfig {
		return {
			accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '',
			channelName: isSet(object.channelName) ? globalThis.String(object.channelName) : '',
			cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : '',
			includeAllMetadata: isSet(object.includeAllMetadata)
				? globalThis.Boolean(object.includeAllMetadata)
				: false,
			includive: isSet(object.includive) ? globalThis.Boolean(object.includive) : false,
			limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: SlackCollectorConfig): unknown {
		const obj: any = {};
		if (message.accessToken !== '') {
			obj.accessToken = message.accessToken;
		}
		if (message.channelName !== '') {
			obj.channelName = message.channelName;
		}
		if (message.cursor !== '') {
			obj.cursor = message.cursor;
		}
		if (message.includeAllMetadata !== false) {
			obj.includeAllMetadata = message.includeAllMetadata;
		}
		if (message.includive !== false) {
			obj.includive = message.includive;
		}
		if (message.limit !== 0) {
			obj.limit = Math.round(message.limit);
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SlackCollectorConfig>, I>>(base?: I): SlackCollectorConfig {
		return SlackCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SlackCollectorConfig>, I>>(
		object: I
	): SlackCollectorConfig {
		const message = createBaseSlackCollectorConfig();
		message.accessToken = object.accessToken ?? '';
		message.channelName = object.channelName ?? '';
		message.cursor = object.cursor ?? '';
		message.includeAllMetadata = object.includeAllMetadata ?? false;
		message.includive = object.includive ?? false;
		message.limit = object.limit ?? 0;
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseNewsCollectorConfig(): NewsCollectorConfig {
	return {
		apiKey: '',
		query: '',
		fromDate: '',
		toDate: '',
		language: '',
		domains: '',
		excludeDomains: '',
		sources: '',
		id: ''
	};
}

export const NewsCollectorConfig = {
	encode(message: NewsCollectorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.apiKey !== '') {
			writer.uint32(10).string(message.apiKey);
		}
		if (message.query !== '') {
			writer.uint32(18).string(message.query);
		}
		if (message.fromDate !== '') {
			writer.uint32(26).string(message.fromDate);
		}
		if (message.toDate !== '') {
			writer.uint32(34).string(message.toDate);
		}
		if (message.language !== '') {
			writer.uint32(42).string(message.language);
		}
		if (message.domains !== '') {
			writer.uint32(50).string(message.domains);
		}
		if (message.excludeDomains !== '') {
			writer.uint32(58).string(message.excludeDomains);
		}
		if (message.sources !== '') {
			writer.uint32(66).string(message.sources);
		}
		if (message.id !== '') {
			writer.uint32(74).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): NewsCollectorConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseNewsCollectorConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.apiKey = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.query = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.fromDate = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.toDate = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.language = reader.string();
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.domains = reader.string();
					continue;
				case 7:
					if (tag !== 58) {
						break;
					}

					message.excludeDomains = reader.string();
					continue;
				case 8:
					if (tag !== 66) {
						break;
					}

					message.sources = reader.string();
					continue;
				case 9:
					if (tag !== 74) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): NewsCollectorConfig {
		return {
			apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : '',
			query: isSet(object.query) ? globalThis.String(object.query) : '',
			fromDate: isSet(object.fromDate) ? globalThis.String(object.fromDate) : '',
			toDate: isSet(object.toDate) ? globalThis.String(object.toDate) : '',
			language: isSet(object.language) ? globalThis.String(object.language) : '',
			domains: isSet(object.domains) ? globalThis.String(object.domains) : '',
			excludeDomains: isSet(object.excludeDomains) ? globalThis.String(object.excludeDomains) : '',
			sources: isSet(object.sources) ? globalThis.String(object.sources) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: NewsCollectorConfig): unknown {
		const obj: any = {};
		if (message.apiKey !== '') {
			obj.apiKey = message.apiKey;
		}
		if (message.query !== '') {
			obj.query = message.query;
		}
		if (message.fromDate !== '') {
			obj.fromDate = message.fromDate;
		}
		if (message.toDate !== '') {
			obj.toDate = message.toDate;
		}
		if (message.language !== '') {
			obj.language = message.language;
		}
		if (message.domains !== '') {
			obj.domains = message.domains;
		}
		if (message.excludeDomains !== '') {
			obj.excludeDomains = message.excludeDomains;
		}
		if (message.sources !== '') {
			obj.sources = message.sources;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<NewsCollectorConfig>, I>>(base?: I): NewsCollectorConfig {
		return NewsCollectorConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<NewsCollectorConfig>, I>>(
		object: I
	): NewsCollectorConfig {
		const message = createBaseNewsCollectorConfig();
		message.apiKey = object.apiKey ?? '';
		message.query = object.query ?? '';
		message.fromDate = object.fromDate ?? '';
		message.toDate = object.toDate ?? '';
		message.language = object.language ?? '';
		message.domains = object.domains ?? '';
		message.excludeDomains = object.excludeDomains ?? '';
		message.sources = object.sources ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

function createBaseOneDriveConfig(): OneDriveConfig {
	return {
		clientId: '',
		clientSecret: '',
		redirectUri: '',
		refreshToken: '',
		folderPath: '',
		id: ''
	};
}

export const OneDriveConfig = {
	encode(message: OneDriveConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
		if (message.clientId !== '') {
			writer.uint32(10).string(message.clientId);
		}
		if (message.clientSecret !== '') {
			writer.uint32(18).string(message.clientSecret);
		}
		if (message.redirectUri !== '') {
			writer.uint32(26).string(message.redirectUri);
		}
		if (message.refreshToken !== '') {
			writer.uint32(34).string(message.refreshToken);
		}
		if (message.folderPath !== '') {
			writer.uint32(42).string(message.folderPath);
		}
		if (message.id !== '') {
			writer.uint32(50).string(message.id);
		}
		return writer;
	},

	decode(input: _m0.Reader | Uint8Array, length?: number): OneDriveConfig {
		const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOneDriveConfig();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.clientId = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.clientSecret = reader.string();
					continue;
				case 3:
					if (tag !== 26) {
						break;
					}

					message.redirectUri = reader.string();
					continue;
				case 4:
					if (tag !== 34) {
						break;
					}

					message.refreshToken = reader.string();
					continue;
				case 5:
					if (tag !== 42) {
						break;
					}

					message.folderPath = reader.string();
					continue;
				case 6:
					if (tag !== 50) {
						break;
					}

					message.id = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skipType(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): OneDriveConfig {
		return {
			clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : '',
			clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : '',
			redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : '',
			refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
			folderPath: isSet(object.folderPath) ? globalThis.String(object.folderPath) : '',
			id: isSet(object.id) ? globalThis.String(object.id) : ''
		};
	},

	toJSON(message: OneDriveConfig): unknown {
		const obj: any = {};
		if (message.clientId !== '') {
			obj.clientId = message.clientId;
		}
		if (message.clientSecret !== '') {
			obj.clientSecret = message.clientSecret;
		}
		if (message.redirectUri !== '') {
			obj.redirectUri = message.redirectUri;
		}
		if (message.refreshToken !== '') {
			obj.refreshToken = message.refreshToken;
		}
		if (message.folderPath !== '') {
			obj.folderPath = message.folderPath;
		}
		if (message.id !== '') {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<OneDriveConfig>, I>>(base?: I): OneDriveConfig {
		return OneDriveConfig.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OneDriveConfig>, I>>(object: I): OneDriveConfig {
		const message = createBaseOneDriveConfig();
		message.clientId = object.clientId ?? '';
		message.clientSecret = object.clientSecret ?? '';
		message.redirectUri = object.redirectUri ?? '';
		message.refreshToken = object.refreshToken ?? '';
		message.folderPath = object.folderPath ?? '';
		message.id = object.id ?? '';
		return message;
	}
};

export interface SemanticsService {
	StartPipeline(request: SemanticPipelineRequest): Promise<SemanticPipelineResponse>;
	ObservePipeline(request: EmptyObserve): Promise<SemanticServiceCounters>;
	GetPipelinesMetadata(request: EmptyGetPipelinesMetadata): Promise<PipelinesMetadata>;
	StopPipeline(request: StopPipelineRequest): Promise<BooleanResponse>;
	DescribePipeline(request: DescribePipelineRequest): Promise<IndexingStatistics>;
	IngestTokens(request: SendIngestedTokens): Promise<BooleanResponse>;
	RestartPipeline(request: RestartPipelineRequest): Promise<BooleanResponse>;
	PostCollectors(request: CollectorConfig): Promise<CollectorConfigResponse>;
	DeleteCollectors(request: DeleteCollectorRequest): Promise<DeleteCollectorResponse>;
	ListCollectors(request: ListCollectorRequest): Promise<ListCollectorConfig>;
	ListPipelineInfo(request: EmptyList): Promise<PipelineRequestInfoList>;
}

export const SemanticsServiceServiceName = 'querent.semantics.SemanticsService';
export class SemanticsServiceClientImpl implements SemanticsService {
	private readonly rpc: Rpc;
	private readonly service: string;
	constructor(rpc: Rpc, opts?: { service?: string }) {
		this.service = opts?.service || SemanticsServiceServiceName;
		this.rpc = rpc;
		this.StartPipeline = this.StartPipeline.bind(this);
		this.ObservePipeline = this.ObservePipeline.bind(this);
		this.GetPipelinesMetadata = this.GetPipelinesMetadata.bind(this);
		this.StopPipeline = this.StopPipeline.bind(this);
		this.DescribePipeline = this.DescribePipeline.bind(this);
		this.IngestTokens = this.IngestTokens.bind(this);
		this.RestartPipeline = this.RestartPipeline.bind(this);
		this.PostCollectors = this.PostCollectors.bind(this);
		this.DeleteCollectors = this.DeleteCollectors.bind(this);
		this.ListCollectors = this.ListCollectors.bind(this);
		this.ListPipelineInfo = this.ListPipelineInfo.bind(this);
	}
	StartPipeline(request: SemanticPipelineRequest): Promise<SemanticPipelineResponse> {
		const data = SemanticPipelineRequest.encode(request).finish();
		const promise = this.rpc.request(this.service, 'StartPipeline', data);
		return promise.then((data) => SemanticPipelineResponse.decode(_m0.Reader.create(data)));
	}

	ObservePipeline(request: EmptyObserve): Promise<SemanticServiceCounters> {
		const data = EmptyObserve.encode(request).finish();
		const promise = this.rpc.request(this.service, 'ObservePipeline', data);
		return promise.then((data) => SemanticServiceCounters.decode(_m0.Reader.create(data)));
	}

	GetPipelinesMetadata(request: EmptyGetPipelinesMetadata): Promise<PipelinesMetadata> {
		const data = EmptyGetPipelinesMetadata.encode(request).finish();
		const promise = this.rpc.request(this.service, 'GetPipelinesMetadata', data);
		return promise.then((data) => PipelinesMetadata.decode(_m0.Reader.create(data)));
	}

	StopPipeline(request: StopPipelineRequest): Promise<BooleanResponse> {
		const data = StopPipelineRequest.encode(request).finish();
		const promise = this.rpc.request(this.service, 'StopPipeline', data);
		return promise.then((data) => BooleanResponse.decode(_m0.Reader.create(data)));
	}

	DescribePipeline(request: DescribePipelineRequest): Promise<IndexingStatistics> {
		const data = DescribePipelineRequest.encode(request).finish();
		const promise = this.rpc.request(this.service, 'DescribePipeline', data);
		return promise.then((data) => IndexingStatistics.decode(_m0.Reader.create(data)));
	}

	IngestTokens(request: SendIngestedTokens): Promise<BooleanResponse> {
		const data = SendIngestedTokens.encode(request).finish();
		const promise = this.rpc.request(this.service, 'IngestTokens', data);
		return promise.then((data) => BooleanResponse.decode(_m0.Reader.create(data)));
	}

	RestartPipeline(request: RestartPipelineRequest): Promise<BooleanResponse> {
		const data = RestartPipelineRequest.encode(request).finish();
		const promise = this.rpc.request(this.service, 'RestartPipeline', data);
		return promise.then((data) => BooleanResponse.decode(_m0.Reader.create(data)));
	}

	PostCollectors(request: CollectorConfig): Promise<CollectorConfigResponse> {
		const data = CollectorConfig.encode(request).finish();
		const promise = this.rpc.request(this.service, 'PostCollectors', data);
		return promise.then((data) => CollectorConfigResponse.decode(_m0.Reader.create(data)));
	}

	DeleteCollectors(request: DeleteCollectorRequest): Promise<DeleteCollectorResponse> {
		const data = DeleteCollectorRequest.encode(request).finish();
		const promise = this.rpc.request(this.service, 'DeleteCollectors', data);
		return promise.then((data) => DeleteCollectorResponse.decode(_m0.Reader.create(data)));
	}

	ListCollectors(request: ListCollectorRequest): Promise<ListCollectorConfig> {
		const data = ListCollectorRequest.encode(request).finish();
		const promise = this.rpc.request(this.service, 'ListCollectors', data);
		return promise.then((data) => ListCollectorConfig.decode(_m0.Reader.create(data)));
	}

	ListPipelineInfo(request: EmptyList): Promise<PipelineRequestInfoList> {
		const data = EmptyList.encode(request).finish();
		const promise = this.rpc.request(this.service, 'ListPipelineInfo', data);
		return promise.then((data) => PipelineRequestInfoList.decode(_m0.Reader.create(data)));
	}
}

interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
	if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
		throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
	}
	if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
		throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
	}
	return long.toNumber();
}

if (_m0.util.Long !== Long) {
	_m0.util.Long = Long as any;
	_m0.configure();
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}
